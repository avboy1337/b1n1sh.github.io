// media/mojo/mojom/speech_recognition_service.mojom.js is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

(function() {
  var mojomId = 'media/mojo/mojom/speech_recognition_service.mojom';
  if (mojo.internal.isMojomLoaded(mojomId)) {
    console.warn('The following mojom is loaded multiple times: ' + mojomId);
    return;
  }
  mojo.internal.markMojomLoaded(mojomId);
  var bindings = mojo;
  var associatedBindings = mojo;
  var codec = mojo.internal;
  var validator = mojo.internal;

  var exports = mojo.internal.exposeNamespace('media.mojom');
  var audio_parameters$ =
      mojo.internal.exposeNamespace('media.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'media/mojo/mojom/audio_parameters.mojom', 'audio_parameters.mojom.js');
  }
  var audio_stream_factory$ =
      mojo.internal.exposeNamespace('media.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'media/mojo/mojom/audio_stream_factory.mojom', 'audio_stream_factory.mojom.js');
  }
  var media_types$ =
      mojo.internal.exposeNamespace('media.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'media/mojo/mojom/media_types.mojom', 'media_types.mojom.js');
  }
  var file_path$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/file_path.mojom', '../../../mojo/public/mojom/base/file_path.mojom.js');
  }
  var time$ =
      mojo.internal.exposeNamespace('mojoBase.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'mojo/public/mojom/base/time.mojom', '../../../mojo/public/mojom/base/time.mojom.js');
  }
  var url_loader_factory$ =
      mojo.internal.exposeNamespace('network.mojom');
  if (mojo.config.autoLoadMojomDeps) {
    mojo.internal.loadMojomIfNecessary(
        'services/network/public/mojom/url_loader_factory.mojom', '../../../services/network/public/mojom/url_loader_factory.mojom.js');
  }


  var ConfidenceLevel = {};
  ConfidenceLevel.kUnknown = 0;
  ConfidenceLevel.kNotConfident = 1;
  ConfidenceLevel.kConfident = 2;
  ConfidenceLevel.kHighlyConfident = 3;
  ConfidenceLevel.MIN_VALUE = 0;
  ConfidenceLevel.MAX_VALUE = 3;

  ConfidenceLevel.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    }
    return false;
  };

  ConfidenceLevel.toKnownEnumValue = function(value) {
    return value;
  };

  ConfidenceLevel.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };
  var SpeechRecognitionMode = {};
  SpeechRecognitionMode.kUnknown = 0;
  SpeechRecognitionMode.kIme = 1;
  SpeechRecognitionMode.kCaption = 2;
  SpeechRecognitionMode.MIN_VALUE = 0;
  SpeechRecognitionMode.MAX_VALUE = 2;

  SpeechRecognitionMode.isKnownEnumValue = function(value) {
    switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    }
    return false;
  };

  SpeechRecognitionMode.toKnownEnumValue = function(value) {
    return value;
  };

  SpeechRecognitionMode.validate = function(enumValue) {
    const isExtensible = false;
    if (isExtensible || this.isKnownEnumValue(enumValue))
      return validator.validationError.NONE;

    return validator.validationError.UNKNOWN_ENUM_VALUE;
  };

  function HypothesisParts(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  HypothesisParts.prototype.initDefaults_ = function() {
    this.text = null;
    this.hypothesisPartOffset = null;
  };
  HypothesisParts.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  HypothesisParts.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate HypothesisParts.text
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 0, 8, codec.String, false, [0, 0], 0);
    if (err !== validator.validationError.NONE)
        return err;


    // validate HypothesisParts.hypothesisPartOffset
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  HypothesisParts.encodedSize = codec.kStructHeaderSize + 16;

  HypothesisParts.decode = function(decoder) {
    var packed;
    var val = new HypothesisParts();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.text =
        decoder.decodeArrayPointer(codec.String);
    val.hypothesisPartOffset =
        decoder.decodeStructPointer(time$.TimeDelta);
    return val;
  };

  HypothesisParts.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(HypothesisParts.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeArrayPointer(codec.String, val.text);
    encoder.encodeStructPointer(time$.TimeDelta, val.hypothesisPartOffset);
  };
  function TimingInformation(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  TimingInformation.prototype.initDefaults_ = function() {
    this.audioStartTime = null;
    this.audioEndTime = null;
    this.hypothesisParts = null;
  };
  TimingInformation.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  TimingInformation.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate TimingInformation.audioStartTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate TimingInformation.audioEndTime
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, time$.TimeDelta, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate TimingInformation.hypothesisParts
    err = messageValidator.validateArrayPointer(offset + codec.kStructHeaderSize + 16, 8, new codec.PointerTo(HypothesisParts), true, [0], 0);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  TimingInformation.encodedSize = codec.kStructHeaderSize + 24;

  TimingInformation.decode = function(decoder) {
    var packed;
    var val = new TimingInformation();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.audioStartTime =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.audioEndTime =
        decoder.decodeStructPointer(time$.TimeDelta);
    val.hypothesisParts =
        decoder.decodeArrayPointer(new codec.PointerTo(HypothesisParts));
    return val;
  };

  TimingInformation.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(TimingInformation.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(time$.TimeDelta, val.audioStartTime);
    encoder.encodeStructPointer(time$.TimeDelta, val.audioEndTime);
    encoder.encodeArrayPointer(new codec.PointerTo(HypothesisParts), val.hypothesisParts);
  };
  function SpeechRecognitionResult(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionResult.prototype.initDefaults_ = function() {
    this.transcription = null;
    this.isFinal = false;
    this.timingInformation = null;
  };
  SpeechRecognitionResult.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionResult.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionResult.transcription
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;



    // validate SpeechRecognitionResult.timingInformation
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, TimingInformation, true);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionResult.encodedSize = codec.kStructHeaderSize + 24;

  SpeechRecognitionResult.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionResult();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.transcription =
        decoder.decodeStruct(codec.String);
    packed = decoder.readUint8();
    val.isFinal = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.timingInformation =
        decoder.decodeStructPointer(TimingInformation);
    return val;
  };

  SpeechRecognitionResult.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionResult.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.transcription);
    packed = 0;
    packed |= (val.isFinal & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(TimingInformation, val.timingInformation);
  };
  function LanguageIdentificationEvent(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  LanguageIdentificationEvent.prototype.initDefaults_ = function() {
    this.language = null;
    this.confidenceLevel = 0;
  };
  LanguageIdentificationEvent.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  LanguageIdentificationEvent.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate LanguageIdentificationEvent.language
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate LanguageIdentificationEvent.confidenceLevel
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 8, ConfidenceLevel);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  LanguageIdentificationEvent.encodedSize = codec.kStructHeaderSize + 16;

  LanguageIdentificationEvent.decode = function(decoder) {
    var packed;
    var val = new LanguageIdentificationEvent();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.language =
        decoder.decodeStruct(codec.String);
    val.confidenceLevel =
        decoder.decodeStruct(new codec.Enum(ConfidenceLevel));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  LanguageIdentificationEvent.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(LanguageIdentificationEvent.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.language);
    encoder.encodeStruct(codec.Int32, val.confidenceLevel);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionOptions(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionOptions.prototype.initDefaults_ = function() {
    this.recognitionMode = 0;
    this.enableFormatting = false;
    this.language = null;
  };
  SpeechRecognitionOptions.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionOptions.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionOptions.recognitionMode
    err = messageValidator.validateEnum(offset + codec.kStructHeaderSize + 0, SpeechRecognitionMode);
    if (err !== validator.validationError.NONE)
        return err;



    // validate SpeechRecognitionOptions.language
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, true)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionOptions.encodedSize = codec.kStructHeaderSize + 16;

  SpeechRecognitionOptions.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionOptions();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.recognitionMode =
        decoder.decodeStruct(new codec.Enum(SpeechRecognitionMode));
    packed = decoder.readUint8();
    val.enableFormatting = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.language =
        decoder.decodeStruct(codec.NullableString);
    return val;
  };

  SpeechRecognitionOptions.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionOptions.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.Int32, val.recognitionMode);
    packed = 0;
    packed |= (val.enableFormatting & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStruct(codec.NullableString, val.language);
  };
  function SpeechRecognitionContext_BindRecognizer_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionContext_BindRecognizer_Params.prototype.initDefaults_ = function() {
    this.receiver = new bindings.InterfaceRequest();
    this.client = new SpeechRecognitionRecognizerClientPtr();
    this.options = null;
  };
  SpeechRecognitionContext_BindRecognizer_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionContext_BindRecognizer_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionContext_BindRecognizer_Params.receiver
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionContext_BindRecognizer_Params.client
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 4, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionContext_BindRecognizer_Params.options
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, SpeechRecognitionOptions, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionContext_BindRecognizer_Params.encodedSize = codec.kStructHeaderSize + 24;

  SpeechRecognitionContext_BindRecognizer_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionContext_BindRecognizer_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.receiver =
        decoder.decodeStruct(codec.InterfaceRequest);
    val.client =
        decoder.decodeStruct(new codec.Interface(SpeechRecognitionRecognizerClientPtr));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.options =
        decoder.decodeStructPointer(SpeechRecognitionOptions);
    return val;
  };

  SpeechRecognitionContext_BindRecognizer_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionContext_BindRecognizer_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.receiver);
    encoder.encodeStruct(new codec.Interface(SpeechRecognitionRecognizerClientPtr), val.client);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(SpeechRecognitionOptions, val.options);
  };
  function SpeechRecognitionContext_BindRecognizer_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionContext_BindRecognizer_ResponseParams.prototype.initDefaults_ = function() {
    this.isMultichannelSupported = false;
  };
  SpeechRecognitionContext_BindRecognizer_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionContext_BindRecognizer_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  SpeechRecognitionContext_BindRecognizer_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionContext_BindRecognizer_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionContext_BindRecognizer_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.isMultichannelSupported = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionContext_BindRecognizer_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionContext_BindRecognizer_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.isMultichannelSupported & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionContext_BindAudioSourceFetcher_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionContext_BindAudioSourceFetcher_Params.prototype.initDefaults_ = function() {
    this.fetcherReceiver = new bindings.InterfaceRequest();
    this.client = new SpeechRecognitionRecognizerClientPtr();
    this.options = null;
  };
  SpeechRecognitionContext_BindAudioSourceFetcher_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionContext_BindAudioSourceFetcher_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionContext_BindAudioSourceFetcher_Params.fetcherReceiver
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionContext_BindAudioSourceFetcher_Params.client
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 4, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionContext_BindAudioSourceFetcher_Params.options
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, SpeechRecognitionOptions, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionContext_BindAudioSourceFetcher_Params.encodedSize = codec.kStructHeaderSize + 24;

  SpeechRecognitionContext_BindAudioSourceFetcher_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionContext_BindAudioSourceFetcher_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.fetcherReceiver =
        decoder.decodeStruct(codec.InterfaceRequest);
    val.client =
        decoder.decodeStruct(new codec.Interface(SpeechRecognitionRecognizerClientPtr));
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    val.options =
        decoder.decodeStructPointer(SpeechRecognitionOptions);
    return val;
  };

  SpeechRecognitionContext_BindAudioSourceFetcher_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionContext_BindAudioSourceFetcher_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.fetcherReceiver);
    encoder.encodeStruct(new codec.Interface(SpeechRecognitionRecognizerClientPtr), val.client);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.encodeStructPointer(SpeechRecognitionOptions, val.options);
  };
  function SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams.prototype.initDefaults_ = function() {
    this.isMultichannelSupported = false;
  };
  SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.isMultichannelSupported = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.isMultichannelSupported & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionService_BindContext_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionService_BindContext_Params.prototype.initDefaults_ = function() {
    this.context = new bindings.InterfaceRequest();
  };
  SpeechRecognitionService_BindContext_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionService_BindContext_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_BindContext_Params.context
    err = messageValidator.validateInterfaceRequest(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionService_BindContext_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionService_BindContext_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionService_BindContext_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.context =
        decoder.decodeStruct(codec.InterfaceRequest);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionService_BindContext_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionService_BindContext_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.InterfaceRequest, val.context);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionService_SetUrlLoaderFactory_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionService_SetUrlLoaderFactory_Params.prototype.initDefaults_ = function() {
    this.urlLoaderFactory = new url_loader_factory$.URLLoaderFactoryPtr();
  };
  SpeechRecognitionService_SetUrlLoaderFactory_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionService_SetUrlLoaderFactory_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_SetUrlLoaderFactory_Params.urlLoaderFactory
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionService_SetUrlLoaderFactory_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionService_SetUrlLoaderFactory_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionService_SetUrlLoaderFactory_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.urlLoaderFactory =
        decoder.decodeStruct(new codec.Interface(url_loader_factory$.URLLoaderFactoryPtr));
    return val;
  };

  SpeechRecognitionService_SetUrlLoaderFactory_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionService_SetUrlLoaderFactory_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(url_loader_factory$.URLLoaderFactoryPtr), val.urlLoaderFactory);
  };
  function SpeechRecognitionService_SetSodaPath_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionService_SetSodaPath_Params.prototype.initDefaults_ = function() {
    this.binaryPath = null;
    this.configPath = null;
  };
  SpeechRecognitionService_SetSodaPath_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionService_SetSodaPath_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 24}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_SetSodaPath_Params.binaryPath
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, file_path$.FilePath, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_SetSodaPath_Params.configPath
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 8, file_path$.FilePath, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionService_SetSodaPath_Params.encodedSize = codec.kStructHeaderSize + 16;

  SpeechRecognitionService_SetSodaPath_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionService_SetSodaPath_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.binaryPath =
        decoder.decodeStructPointer(file_path$.FilePath);
    val.configPath =
        decoder.decodeStructPointer(file_path$.FilePath);
    return val;
  };

  SpeechRecognitionService_SetSodaPath_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionService_SetSodaPath_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(file_path$.FilePath, val.binaryPath);
    encoder.encodeStructPointer(file_path$.FilePath, val.configPath);
  };
  function SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.prototype.initDefaults_ = function() {
    this.client = new SpeechRecognitionServiceClientPtr();
  };
  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.client
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.client =
        decoder.decodeStruct(new codec.Interface(SpeechRecognitionServiceClientPtr));
    return val;
  };

  SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(SpeechRecognitionServiceClientPtr), val.client);
  };
  function AudioSourceFetcher_Start_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioSourceFetcher_Start_Params.prototype.initDefaults_ = function() {
    this.factory = new audio_stream_factory$.AudioStreamFactoryPtr();
    this.deviceId = null;
    this.audioParameters = null;
  };
  AudioSourceFetcher_Start_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioSourceFetcher_Start_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 32}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioSourceFetcher_Start_Params.factory
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioSourceFetcher_Start_Params.deviceId
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 8, false)
    if (err !== validator.validationError.NONE)
        return err;


    // validate AudioSourceFetcher_Start_Params.audioParameters
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 16, audio_parameters$.AudioParameters, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioSourceFetcher_Start_Params.encodedSize = codec.kStructHeaderSize + 24;

  AudioSourceFetcher_Start_Params.decode = function(decoder) {
    var packed;
    var val = new AudioSourceFetcher_Start_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.factory =
        decoder.decodeStruct(new codec.Interface(audio_stream_factory$.AudioStreamFactoryPtr));
    val.deviceId =
        decoder.decodeStruct(codec.String);
    val.audioParameters =
        decoder.decodeStructPointer(audio_parameters$.AudioParameters);
    return val;
  };

  AudioSourceFetcher_Start_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioSourceFetcher_Start_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(audio_stream_factory$.AudioStreamFactoryPtr), val.factory);
    encoder.encodeStruct(codec.String, val.deviceId);
    encoder.encodeStructPointer(audio_parameters$.AudioParameters, val.audioParameters);
  };
  function AudioSourceFetcher_Stop_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  AudioSourceFetcher_Stop_Params.prototype.initDefaults_ = function() {
  };
  AudioSourceFetcher_Stop_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  AudioSourceFetcher_Stop_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  AudioSourceFetcher_Stop_Params.encodedSize = codec.kStructHeaderSize + 0;

  AudioSourceFetcher_Stop_Params.decode = function(decoder) {
    var packed;
    var val = new AudioSourceFetcher_Stop_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  AudioSourceFetcher_Stop_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(AudioSourceFetcher_Stop_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.prototype.initDefaults_ = function() {
  };
  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.encodedSize = codec.kStructHeaderSize + 0;

  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.prototype.initDefaults_ = function() {
    this.buffer = null;
  };
  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.buffer
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, media_types$.AudioDataS16, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.buffer =
        decoder.decodeStructPointer(media_types$.AudioDataS16);
    return val;
  };

  SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(media_types$.AudioDataS16, val.buffer);
  };
  function SpeechRecognitionRecognizer_OnLanguageChanged_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizer_OnLanguageChanged_Params.prototype.initDefaults_ = function() {
    this.language = null;
  };
  SpeechRecognitionRecognizer_OnLanguageChanged_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizer_OnLanguageChanged_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionRecognizer_OnLanguageChanged_Params.language
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizer_OnLanguageChanged_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionRecognizer_OnLanguageChanged_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizer_OnLanguageChanged_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.language =
        decoder.decodeStruct(codec.String);
    return val;
  };

  SpeechRecognitionRecognizer_OnLanguageChanged_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizer_OnLanguageChanged_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.language);
  };
  function SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.prototype.initDefaults_ = function() {
    this.result = null;
  };
  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.result
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, SpeechRecognitionResult, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.result =
        decoder.decodeStructPointer(SpeechRecognitionResult);
    return val;
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(SpeechRecognitionResult, val.result);
  };
  function SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams.prototype.initDefaults_ = function() {
    this.success = false;
  };
  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.success = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.success & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params.prototype.initDefaults_ = function() {
  };
  SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 8}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params.encodedSize = codec.kStructHeaderSize + 0;

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    return val;
  };

  SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params.encodedSize);
    encoder.writeUint32(0);
  };
  function SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params.prototype.initDefaults_ = function() {
    this.event = null;
  };
  SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params.event
    err = messageValidator.validateStructPointer(offset + codec.kStructHeaderSize + 0, LanguageIdentificationEvent, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.event =
        decoder.decodeStructPointer(LanguageIdentificationEvent);
    return val;
  };

  SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStructPointer(LanguageIdentificationEvent, val.event);
  };
  function SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params.prototype.initDefaults_ = function() {
    this.isSpeechRecognitionAvailable = false;
  };
  SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    return validator.validationError.NONE;
  };

  SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    packed = decoder.readUint8();
    val.isSpeechRecognitionAvailable = (packed >> 0) & 1 ? true : false;
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    decoder.skip(1);
    return val;
  };

  SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params.encodedSize);
    encoder.writeUint32(0);
    packed = 0;
    packed |= (val.isSpeechRecognitionAvailable & 1) << 0
    encoder.writeUint8(packed);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
    encoder.skip(1);
  };
  function SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params.prototype.initDefaults_ = function() {
    this.language = null;
  };
  SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params.language
    err = messageValidator.validateStringPointer(offset + codec.kStructHeaderSize + 0, false)
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.language =
        decoder.decodeStruct(codec.String);
    return val;
  };

  SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(codec.String, val.language);
  };
  function SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params(values) {
    this.initDefaults_();
    this.initFields_(values);
  }


  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params.prototype.initDefaults_ = function() {
    this.observer = new SpeechRecognitionBrowserObserverPtr();
  };
  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params.prototype.initFields_ = function(fields) {
    for(var field in fields) {
        if (this.hasOwnProperty(field))
          this[field] = fields[field];
    }
  };

  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params.validate = function(messageValidator, offset) {
    var err;
    err = messageValidator.validateStructHeader(offset, codec.kStructHeaderSize);
    if (err !== validator.validationError.NONE)
        return err;

    var kVersionSizes = [
      {version: 0, numBytes: 16}
    ];
    err = messageValidator.validateStructVersion(offset, kVersionSizes);
    if (err !== validator.validationError.NONE)
        return err;


    // validate SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params.observer
    err = messageValidator.validateInterface(offset + codec.kStructHeaderSize + 0, false);
    if (err !== validator.validationError.NONE)
        return err;

    return validator.validationError.NONE;
  };

  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params.encodedSize = codec.kStructHeaderSize + 8;

  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params.decode = function(decoder) {
    var packed;
    var val = new SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params();
    var numberOfBytes = decoder.readUint32();
    var version = decoder.readUint32();
    val.observer =
        decoder.decodeStruct(new codec.Interface(SpeechRecognitionBrowserObserverPtr));
    return val;
  };

  SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params.encode = function(encoder, val) {
    var packed;
    encoder.writeUint32(SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params.encodedSize);
    encoder.writeUint32(0);
    encoder.encodeStruct(new codec.Interface(SpeechRecognitionBrowserObserverPtr), val.observer);
  };
  var kSpeechRecognitionContext_BindRecognizer_Name = 1135126946;
  var kSpeechRecognitionContext_BindAudioSourceFetcher_Name = 375974951;

  function SpeechRecognitionContextPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionContext,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionContextAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionContext, associatedInterfacePtrInfo);
  }

  SpeechRecognitionContextAssociatedPtr.prototype =
      Object.create(SpeechRecognitionContextPtr.prototype);
  SpeechRecognitionContextAssociatedPtr.prototype.constructor =
      SpeechRecognitionContextAssociatedPtr;

  function SpeechRecognitionContextProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionContextPtr.prototype.bindRecognizer = function() {
    return SpeechRecognitionContextProxy.prototype.bindRecognizer
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionContextProxy.prototype.bindRecognizer = function(receiver, client, options) {
    var params_ = new SpeechRecognitionContext_BindRecognizer_Params();
    params_.receiver = receiver;
    params_.client = client;
    params_.options = options;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kSpeechRecognitionContext_BindRecognizer_Name,
          codec.align(SpeechRecognitionContext_BindRecognizer_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(SpeechRecognitionContext_BindRecognizer_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(SpeechRecognitionContext_BindRecognizer_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  SpeechRecognitionContextPtr.prototype.bindAudioSourceFetcher = function() {
    return SpeechRecognitionContextProxy.prototype.bindAudioSourceFetcher
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionContextProxy.prototype.bindAudioSourceFetcher = function(fetcherReceiver, client, options) {
    var params_ = new SpeechRecognitionContext_BindAudioSourceFetcher_Params();
    params_.fetcherReceiver = fetcherReceiver;
    params_.client = client;
    params_.options = options;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kSpeechRecognitionContext_BindAudioSourceFetcher_Name,
          codec.align(SpeechRecognitionContext_BindAudioSourceFetcher_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(SpeechRecognitionContext_BindAudioSourceFetcher_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };

  function SpeechRecognitionContextStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionContextStub.prototype.bindRecognizer = function(receiver, client, options) {
    return this.delegate_ && this.delegate_.bindRecognizer && this.delegate_.bindRecognizer(receiver, client, options);
  }
  SpeechRecognitionContextStub.prototype.bindAudioSourceFetcher = function(fetcherReceiver, client, options) {
    return this.delegate_ && this.delegate_.bindAudioSourceFetcher && this.delegate_.bindAudioSourceFetcher(fetcherReceiver, client, options);
  }

  SpeechRecognitionContextStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  SpeechRecognitionContextStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionContext_BindRecognizer_Name:
      var params = reader.decodeStruct(SpeechRecognitionContext_BindRecognizer_Params);
      this.bindRecognizer(params.receiver, params.client, params.options).then(function(response) {
        var responseParams =
            new SpeechRecognitionContext_BindRecognizer_ResponseParams();
        responseParams.isMultichannelSupported = response.isMultichannelSupported;
        var builder = new codec.MessageV1Builder(
            kSpeechRecognitionContext_BindRecognizer_Name,
            codec.align(SpeechRecognitionContext_BindRecognizer_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(SpeechRecognitionContext_BindRecognizer_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    case kSpeechRecognitionContext_BindAudioSourceFetcher_Name:
      var params = reader.decodeStruct(SpeechRecognitionContext_BindAudioSourceFetcher_Params);
      this.bindAudioSourceFetcher(params.fetcherReceiver, params.client, params.options).then(function(response) {
        var responseParams =
            new SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams();
        responseParams.isMultichannelSupported = response.isMultichannelSupported;
        var builder = new codec.MessageV1Builder(
            kSpeechRecognitionContext_BindAudioSourceFetcher_Name,
            codec.align(SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateSpeechRecognitionContextRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionContext_BindRecognizer_Name:
        if (message.expectsResponse())
          paramsClass = SpeechRecognitionContext_BindRecognizer_Params;
      break;
      case kSpeechRecognitionContext_BindAudioSourceFetcher_Name:
        if (message.expectsResponse())
          paramsClass = SpeechRecognitionContext_BindAudioSourceFetcher_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionContextResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kSpeechRecognitionContext_BindRecognizer_Name:
        if (message.isResponse())
          paramsClass = SpeechRecognitionContext_BindRecognizer_ResponseParams;
        break;
      case kSpeechRecognitionContext_BindAudioSourceFetcher_Name:
        if (message.isResponse())
          paramsClass = SpeechRecognitionContext_BindAudioSourceFetcher_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var SpeechRecognitionContext = {
    name: 'media.mojom.SpeechRecognitionContext',
    kVersion: 0,
    ptrClass: SpeechRecognitionContextPtr,
    proxyClass: SpeechRecognitionContextProxy,
    stubClass: SpeechRecognitionContextStub,
    validateRequest: validateSpeechRecognitionContextRequest,
    validateResponse: validateSpeechRecognitionContextResponse,
  };
  SpeechRecognitionContextStub.prototype.validator = validateSpeechRecognitionContextRequest;
  SpeechRecognitionContextProxy.prototype.validator = validateSpeechRecognitionContextResponse;
  var kSpeechRecognitionService_BindContext_Name = 43753329;
  var kSpeechRecognitionService_SetUrlLoaderFactory_Name = 1243371221;
  var kSpeechRecognitionService_SetSodaPath_Name = 1917547230;
  var kSpeechRecognitionService_BindSpeechRecognitionServiceClient_Name = 16081880;

  function SpeechRecognitionServicePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionService,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionServiceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionService, associatedInterfacePtrInfo);
  }

  SpeechRecognitionServiceAssociatedPtr.prototype =
      Object.create(SpeechRecognitionServicePtr.prototype);
  SpeechRecognitionServiceAssociatedPtr.prototype.constructor =
      SpeechRecognitionServiceAssociatedPtr;

  function SpeechRecognitionServiceProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionServicePtr.prototype.bindContext = function() {
    return SpeechRecognitionServiceProxy.prototype.bindContext
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceProxy.prototype.bindContext = function(context) {
    var params_ = new SpeechRecognitionService_BindContext_Params();
    params_.context = context;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionService_BindContext_Name,
        codec.align(SpeechRecognitionService_BindContext_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionService_BindContext_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionServicePtr.prototype.setUrlLoaderFactory = function() {
    return SpeechRecognitionServiceProxy.prototype.setUrlLoaderFactory
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceProxy.prototype.setUrlLoaderFactory = function(urlLoaderFactory) {
    var params_ = new SpeechRecognitionService_SetUrlLoaderFactory_Params();
    params_.urlLoaderFactory = urlLoaderFactory;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionService_SetUrlLoaderFactory_Name,
        codec.align(SpeechRecognitionService_SetUrlLoaderFactory_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionService_SetUrlLoaderFactory_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionServicePtr.prototype.setSodaPath = function() {
    return SpeechRecognitionServiceProxy.prototype.setSodaPath
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceProxy.prototype.setSodaPath = function(binaryPath, configPath) {
    var params_ = new SpeechRecognitionService_SetSodaPath_Params();
    params_.binaryPath = binaryPath;
    params_.configPath = configPath;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionService_SetSodaPath_Name,
        codec.align(SpeechRecognitionService_SetSodaPath_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionService_SetSodaPath_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionServicePtr.prototype.bindSpeechRecognitionServiceClient = function() {
    return SpeechRecognitionServiceProxy.prototype.bindSpeechRecognitionServiceClient
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceProxy.prototype.bindSpeechRecognitionServiceClient = function(client) {
    var params_ = new SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params();
    params_.client = client;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionService_BindSpeechRecognitionServiceClient_Name,
        codec.align(SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionServiceStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionServiceStub.prototype.bindContext = function(context) {
    return this.delegate_ && this.delegate_.bindContext && this.delegate_.bindContext(context);
  }
  SpeechRecognitionServiceStub.prototype.setUrlLoaderFactory = function(urlLoaderFactory) {
    return this.delegate_ && this.delegate_.setUrlLoaderFactory && this.delegate_.setUrlLoaderFactory(urlLoaderFactory);
  }
  SpeechRecognitionServiceStub.prototype.setSodaPath = function(binaryPath, configPath) {
    return this.delegate_ && this.delegate_.setSodaPath && this.delegate_.setSodaPath(binaryPath, configPath);
  }
  SpeechRecognitionServiceStub.prototype.bindSpeechRecognitionServiceClient = function(client) {
    return this.delegate_ && this.delegate_.bindSpeechRecognitionServiceClient && this.delegate_.bindSpeechRecognitionServiceClient(client);
  }

  SpeechRecognitionServiceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionService_BindContext_Name:
      var params = reader.decodeStruct(SpeechRecognitionService_BindContext_Params);
      this.bindContext(params.context);
      return true;
    case kSpeechRecognitionService_SetUrlLoaderFactory_Name:
      var params = reader.decodeStruct(SpeechRecognitionService_SetUrlLoaderFactory_Params);
      this.setUrlLoaderFactory(params.urlLoaderFactory);
      return true;
    case kSpeechRecognitionService_SetSodaPath_Name:
      var params = reader.decodeStruct(SpeechRecognitionService_SetSodaPath_Params);
      this.setSodaPath(params.binaryPath, params.configPath);
      return true;
    case kSpeechRecognitionService_BindSpeechRecognitionServiceClient_Name:
      var params = reader.decodeStruct(SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params);
      this.bindSpeechRecognitionServiceClient(params.client);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionServiceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionServiceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionService_BindContext_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionService_BindContext_Params;
      break;
      case kSpeechRecognitionService_SetUrlLoaderFactory_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionService_SetUrlLoaderFactory_Params;
      break;
      case kSpeechRecognitionService_SetSodaPath_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionService_SetSodaPath_Params;
      break;
      case kSpeechRecognitionService_BindSpeechRecognitionServiceClient_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionService_BindSpeechRecognitionServiceClient_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionServiceResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionService = {
    name: 'media.mojom.SpeechRecognitionService',
    kVersion: 0,
    ptrClass: SpeechRecognitionServicePtr,
    proxyClass: SpeechRecognitionServiceProxy,
    stubClass: SpeechRecognitionServiceStub,
    validateRequest: validateSpeechRecognitionServiceRequest,
    validateResponse: null,
  };
  SpeechRecognitionServiceStub.prototype.validator = validateSpeechRecognitionServiceRequest;
  SpeechRecognitionServiceProxy.prototype.validator = null;
  var kAudioSourceFetcher_Start_Name = 829531131;
  var kAudioSourceFetcher_Stop_Name = 813277794;

  function AudioSourceFetcherPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(AudioSourceFetcher,
                                                   handleOrPtrInfo);
  }

  function AudioSourceFetcherAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        AudioSourceFetcher, associatedInterfacePtrInfo);
  }

  AudioSourceFetcherAssociatedPtr.prototype =
      Object.create(AudioSourceFetcherPtr.prototype);
  AudioSourceFetcherAssociatedPtr.prototype.constructor =
      AudioSourceFetcherAssociatedPtr;

  function AudioSourceFetcherProxy(receiver) {
    this.receiver_ = receiver;
  }
  AudioSourceFetcherPtr.prototype.start = function() {
    return AudioSourceFetcherProxy.prototype.start
        .apply(this.ptr.getProxy(), arguments);
  };

  AudioSourceFetcherProxy.prototype.start = function(factory, deviceId, audioParameters) {
    var params_ = new AudioSourceFetcher_Start_Params();
    params_.factory = factory;
    params_.deviceId = deviceId;
    params_.audioParameters = audioParameters;
    var builder = new codec.MessageV0Builder(
        kAudioSourceFetcher_Start_Name,
        codec.align(AudioSourceFetcher_Start_Params.encodedSize));
    builder.encodeStruct(AudioSourceFetcher_Start_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  AudioSourceFetcherPtr.prototype.stop = function() {
    return AudioSourceFetcherProxy.prototype.stop
        .apply(this.ptr.getProxy(), arguments);
  };

  AudioSourceFetcherProxy.prototype.stop = function() {
    var params_ = new AudioSourceFetcher_Stop_Params();
    var builder = new codec.MessageV0Builder(
        kAudioSourceFetcher_Stop_Name,
        codec.align(AudioSourceFetcher_Stop_Params.encodedSize));
    builder.encodeStruct(AudioSourceFetcher_Stop_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function AudioSourceFetcherStub(delegate) {
    this.delegate_ = delegate;
  }
  AudioSourceFetcherStub.prototype.start = function(factory, deviceId, audioParameters) {
    return this.delegate_ && this.delegate_.start && this.delegate_.start(factory, deviceId, audioParameters);
  }
  AudioSourceFetcherStub.prototype.stop = function() {
    return this.delegate_ && this.delegate_.stop && this.delegate_.stop();
  }

  AudioSourceFetcherStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kAudioSourceFetcher_Start_Name:
      var params = reader.decodeStruct(AudioSourceFetcher_Start_Params);
      this.start(params.factory, params.deviceId, params.audioParameters);
      return true;
    case kAudioSourceFetcher_Stop_Name:
      var params = reader.decodeStruct(AudioSourceFetcher_Stop_Params);
      this.stop();
      return true;
    default:
      return false;
    }
  };

  AudioSourceFetcherStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateAudioSourceFetcherRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kAudioSourceFetcher_Start_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = AudioSourceFetcher_Start_Params;
      break;
      case kAudioSourceFetcher_Stop_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = AudioSourceFetcher_Stop_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateAudioSourceFetcherResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var AudioSourceFetcher = {
    name: 'media.mojom.AudioSourceFetcher',
    kVersion: 0,
    ptrClass: AudioSourceFetcherPtr,
    proxyClass: AudioSourceFetcherProxy,
    stubClass: AudioSourceFetcherStub,
    validateRequest: validateAudioSourceFetcherRequest,
    validateResponse: null,
  };
  AudioSourceFetcherStub.prototype.validator = validateAudioSourceFetcherRequest;
  AudioSourceFetcherProxy.prototype.validator = null;
  var kSpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Name = 682109105;

  function SpeechRecognitionServiceClientPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionServiceClient,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionServiceClientAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionServiceClient, associatedInterfacePtrInfo);
  }

  SpeechRecognitionServiceClientAssociatedPtr.prototype =
      Object.create(SpeechRecognitionServiceClientPtr.prototype);
  SpeechRecognitionServiceClientAssociatedPtr.prototype.constructor =
      SpeechRecognitionServiceClientAssociatedPtr;

  function SpeechRecognitionServiceClientProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionServiceClientPtr.prototype.onNetworkServiceDisconnect = function() {
    return SpeechRecognitionServiceClientProxy.prototype.onNetworkServiceDisconnect
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionServiceClientProxy.prototype.onNetworkServiceDisconnect = function() {
    var params_ = new SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params();
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Name,
        codec.align(SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionServiceClientStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionServiceClientStub.prototype.onNetworkServiceDisconnect = function() {
    return this.delegate_ && this.delegate_.onNetworkServiceDisconnect && this.delegate_.onNetworkServiceDisconnect();
  }

  SpeechRecognitionServiceClientStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Name:
      var params = reader.decodeStruct(SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params);
      this.onNetworkServiceDisconnect();
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionServiceClientStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionServiceClientRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionServiceClient_OnNetworkServiceDisconnect_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionServiceClientResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionServiceClient = {
    name: 'media.mojom.SpeechRecognitionServiceClient',
    kVersion: 0,
    ptrClass: SpeechRecognitionServiceClientPtr,
    proxyClass: SpeechRecognitionServiceClientProxy,
    stubClass: SpeechRecognitionServiceClientStub,
    validateRequest: validateSpeechRecognitionServiceClientRequest,
    validateResponse: null,
  };
  SpeechRecognitionServiceClientStub.prototype.validator = validateSpeechRecognitionServiceClientRequest;
  SpeechRecognitionServiceClientProxy.prototype.validator = null;
  var kSpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Name = 582588179;
  var kSpeechRecognitionRecognizer_OnLanguageChanged_Name = 125394888;

  function SpeechRecognitionRecognizerPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionRecognizer,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionRecognizerAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionRecognizer, associatedInterfacePtrInfo);
  }

  SpeechRecognitionRecognizerAssociatedPtr.prototype =
      Object.create(SpeechRecognitionRecognizerPtr.prototype);
  SpeechRecognitionRecognizerAssociatedPtr.prototype.constructor =
      SpeechRecognitionRecognizerAssociatedPtr;

  function SpeechRecognitionRecognizerProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionRecognizerPtr.prototype.sendAudioToSpeechRecognitionService = function() {
    return SpeechRecognitionRecognizerProxy.prototype.sendAudioToSpeechRecognitionService
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionRecognizerProxy.prototype.sendAudioToSpeechRecognitionService = function(buffer) {
    var params_ = new SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params();
    params_.buffer = buffer;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Name,
        codec.align(SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionRecognizerPtr.prototype.onLanguageChanged = function() {
    return SpeechRecognitionRecognizerProxy.prototype.onLanguageChanged
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionRecognizerProxy.prototype.onLanguageChanged = function(language) {
    var params_ = new SpeechRecognitionRecognizer_OnLanguageChanged_Params();
    params_.language = language;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionRecognizer_OnLanguageChanged_Name,
        codec.align(SpeechRecognitionRecognizer_OnLanguageChanged_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionRecognizer_OnLanguageChanged_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionRecognizerStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionRecognizerStub.prototype.sendAudioToSpeechRecognitionService = function(buffer) {
    return this.delegate_ && this.delegate_.sendAudioToSpeechRecognitionService && this.delegate_.sendAudioToSpeechRecognitionService(buffer);
  }
  SpeechRecognitionRecognizerStub.prototype.onLanguageChanged = function(language) {
    return this.delegate_ && this.delegate_.onLanguageChanged && this.delegate_.onLanguageChanged(language);
  }

  SpeechRecognitionRecognizerStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Name:
      var params = reader.decodeStruct(SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params);
      this.sendAudioToSpeechRecognitionService(params.buffer);
      return true;
    case kSpeechRecognitionRecognizer_OnLanguageChanged_Name:
      var params = reader.decodeStruct(SpeechRecognitionRecognizer_OnLanguageChanged_Params);
      this.onLanguageChanged(params.language);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionRecognizerStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionRecognizerRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionRecognizer_SendAudioToSpeechRecognitionService_Params;
      break;
      case kSpeechRecognitionRecognizer_OnLanguageChanged_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionRecognizer_OnLanguageChanged_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionRecognizerResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionRecognizer = {
    name: 'media.mojom.SpeechRecognitionRecognizer',
    kVersion: 0,
    ptrClass: SpeechRecognitionRecognizerPtr,
    proxyClass: SpeechRecognitionRecognizerProxy,
    stubClass: SpeechRecognitionRecognizerStub,
    validateRequest: validateSpeechRecognitionRecognizerRequest,
    validateResponse: null,
  };
  SpeechRecognitionRecognizerStub.prototype.validator = validateSpeechRecognitionRecognizerRequest;
  SpeechRecognitionRecognizerProxy.prototype.validator = null;
  var kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name = 93493573;
  var kSpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Name = 1655605189;
  var kSpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Name = 1237922906;

  function SpeechRecognitionRecognizerClientPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionRecognizerClient,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionRecognizerClientAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionRecognizerClient, associatedInterfacePtrInfo);
  }

  SpeechRecognitionRecognizerClientAssociatedPtr.prototype =
      Object.create(SpeechRecognitionRecognizerClientPtr.prototype);
  SpeechRecognitionRecognizerClientAssociatedPtr.prototype.constructor =
      SpeechRecognitionRecognizerClientAssociatedPtr;

  function SpeechRecognitionRecognizerClientProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionRecognizerClientPtr.prototype.onSpeechRecognitionRecognitionEvent = function() {
    return SpeechRecognitionRecognizerClientProxy.prototype.onSpeechRecognitionRecognitionEvent
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionRecognizerClientProxy.prototype.onSpeechRecognitionRecognitionEvent = function(result) {
    var params_ = new SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params();
    params_.result = result;
    return new Promise(function(resolve, reject) {
      var builder = new codec.MessageV1Builder(
          kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name,
          codec.align(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params.encodedSize),
          codec.kMessageExpectsResponse, 0);
      builder.encodeStruct(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params, params_);
      var message = builder.finish();
      this.receiver_.acceptAndExpectResponse(message).then(function(message) {
        var reader = new codec.MessageReader(message);
        var responseParams =
            reader.decodeStruct(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams);
        resolve(responseParams);
      }).catch(function(result) {
        reject(Error("Connection error: " + result));
      });
    }.bind(this));
  };
  SpeechRecognitionRecognizerClientPtr.prototype.onSpeechRecognitionError = function() {
    return SpeechRecognitionRecognizerClientProxy.prototype.onSpeechRecognitionError
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionRecognizerClientProxy.prototype.onSpeechRecognitionError = function() {
    var params_ = new SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params();
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Name,
        codec.align(SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionRecognizerClientPtr.prototype.onLanguageIdentificationEvent = function() {
    return SpeechRecognitionRecognizerClientProxy.prototype.onLanguageIdentificationEvent
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionRecognizerClientProxy.prototype.onLanguageIdentificationEvent = function(event) {
    var params_ = new SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params();
    params_.event = event;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Name,
        codec.align(SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionRecognizerClientStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionRecognizerClientStub.prototype.onSpeechRecognitionRecognitionEvent = function(result) {
    return this.delegate_ && this.delegate_.onSpeechRecognitionRecognitionEvent && this.delegate_.onSpeechRecognitionRecognitionEvent(result);
  }
  SpeechRecognitionRecognizerClientStub.prototype.onSpeechRecognitionError = function() {
    return this.delegate_ && this.delegate_.onSpeechRecognitionError && this.delegate_.onSpeechRecognitionError();
  }
  SpeechRecognitionRecognizerClientStub.prototype.onLanguageIdentificationEvent = function(event) {
    return this.delegate_ && this.delegate_.onLanguageIdentificationEvent && this.delegate_.onLanguageIdentificationEvent(event);
  }

  SpeechRecognitionRecognizerClientStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Name:
      var params = reader.decodeStruct(SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params);
      this.onSpeechRecognitionError();
      return true;
    case kSpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Name:
      var params = reader.decodeStruct(SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params);
      this.onLanguageIdentificationEvent(params.event);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionRecognizerClientStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name:
      var params = reader.decodeStruct(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params);
      this.onSpeechRecognitionRecognitionEvent(params.result).then(function(response) {
        var responseParams =
            new SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams();
        responseParams.success = response.success;
        var builder = new codec.MessageV1Builder(
            kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name,
            codec.align(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams.encodedSize),
            codec.kMessageIsResponse, reader.requestID);
        builder.encodeStruct(SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams,
                             responseParams);
        var message = builder.finish();
        responder.accept(message);
      });
      return true;
    default:
      return false;
    }
  };

  function validateSpeechRecognitionRecognizerClientRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name:
        if (message.expectsResponse())
          paramsClass = SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Params;
      break;
      case kSpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionRecognizerClient_OnSpeechRecognitionError_Params;
      break;
      case kSpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionRecognizerClient_OnLanguageIdentificationEvent_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionRecognizerClientResponse(messageValidator) {
   var message = messageValidator.message;
   var paramsClass = null;
   switch (message.getName()) {
      case kSpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_Name:
        if (message.isResponse())
          paramsClass = SpeechRecognitionRecognizerClient_OnSpeechRecognitionRecognitionEvent_ResponseParams;
        break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  var SpeechRecognitionRecognizerClient = {
    name: 'media.mojom.SpeechRecognitionRecognizerClient',
    kVersion: 0,
    ptrClass: SpeechRecognitionRecognizerClientPtr,
    proxyClass: SpeechRecognitionRecognizerClientProxy,
    stubClass: SpeechRecognitionRecognizerClientStub,
    validateRequest: validateSpeechRecognitionRecognizerClientRequest,
    validateResponse: validateSpeechRecognitionRecognizerClientResponse,
  };
  SpeechRecognitionRecognizerClientStub.prototype.validator = validateSpeechRecognitionRecognizerClientRequest;
  SpeechRecognitionRecognizerClientProxy.prototype.validator = validateSpeechRecognitionRecognizerClientResponse;
  var kSpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Name = 1108918931;
  var kSpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Name = 330578446;

  function SpeechRecognitionBrowserObserverPtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionBrowserObserver,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionBrowserObserverAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionBrowserObserver, associatedInterfacePtrInfo);
  }

  SpeechRecognitionBrowserObserverAssociatedPtr.prototype =
      Object.create(SpeechRecognitionBrowserObserverPtr.prototype);
  SpeechRecognitionBrowserObserverAssociatedPtr.prototype.constructor =
      SpeechRecognitionBrowserObserverAssociatedPtr;

  function SpeechRecognitionBrowserObserverProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionBrowserObserverPtr.prototype.speechRecognitionAvailabilityChanged = function() {
    return SpeechRecognitionBrowserObserverProxy.prototype.speechRecognitionAvailabilityChanged
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionBrowserObserverProxy.prototype.speechRecognitionAvailabilityChanged = function(isSpeechRecognitionAvailable) {
    var params_ = new SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params();
    params_.isSpeechRecognitionAvailable = isSpeechRecognitionAvailable;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Name,
        codec.align(SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };
  SpeechRecognitionBrowserObserverPtr.prototype.speechRecognitionLanguageChanged = function() {
    return SpeechRecognitionBrowserObserverProxy.prototype.speechRecognitionLanguageChanged
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionBrowserObserverProxy.prototype.speechRecognitionLanguageChanged = function(language) {
    var params_ = new SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params();
    params_.language = language;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Name,
        codec.align(SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionBrowserObserverStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionBrowserObserverStub.prototype.speechRecognitionAvailabilityChanged = function(isSpeechRecognitionAvailable) {
    return this.delegate_ && this.delegate_.speechRecognitionAvailabilityChanged && this.delegate_.speechRecognitionAvailabilityChanged(isSpeechRecognitionAvailable);
  }
  SpeechRecognitionBrowserObserverStub.prototype.speechRecognitionLanguageChanged = function(language) {
    return this.delegate_ && this.delegate_.speechRecognitionLanguageChanged && this.delegate_.speechRecognitionLanguageChanged(language);
  }

  SpeechRecognitionBrowserObserverStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Name:
      var params = reader.decodeStruct(SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params);
      this.speechRecognitionAvailabilityChanged(params.isSpeechRecognitionAvailable);
      return true;
    case kSpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Name:
      var params = reader.decodeStruct(SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params);
      this.speechRecognitionLanguageChanged(params.language);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionBrowserObserverStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionBrowserObserverRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionBrowserObserver_SpeechRecognitionAvailabilityChanged_Params;
      break;
      case kSpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionBrowserObserver_SpeechRecognitionLanguageChanged_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionBrowserObserverResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionBrowserObserver = {
    name: 'media.mojom.SpeechRecognitionBrowserObserver',
    kVersion: 0,
    ptrClass: SpeechRecognitionBrowserObserverPtr,
    proxyClass: SpeechRecognitionBrowserObserverProxy,
    stubClass: SpeechRecognitionBrowserObserverStub,
    validateRequest: validateSpeechRecognitionBrowserObserverRequest,
    validateResponse: null,
  };
  SpeechRecognitionBrowserObserverStub.prototype.validator = validateSpeechRecognitionBrowserObserverRequest;
  SpeechRecognitionBrowserObserverProxy.prototype.validator = null;
  var kSpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Name = 1208696578;

  function SpeechRecognitionClientBrowserInterfacePtr(handleOrPtrInfo) {
    this.ptr = new bindings.InterfacePtrController(SpeechRecognitionClientBrowserInterface,
                                                   handleOrPtrInfo);
  }

  function SpeechRecognitionClientBrowserInterfaceAssociatedPtr(associatedInterfacePtrInfo) {
    this.ptr = new associatedBindings.AssociatedInterfacePtrController(
        SpeechRecognitionClientBrowserInterface, associatedInterfacePtrInfo);
  }

  SpeechRecognitionClientBrowserInterfaceAssociatedPtr.prototype =
      Object.create(SpeechRecognitionClientBrowserInterfacePtr.prototype);
  SpeechRecognitionClientBrowserInterfaceAssociatedPtr.prototype.constructor =
      SpeechRecognitionClientBrowserInterfaceAssociatedPtr;

  function SpeechRecognitionClientBrowserInterfaceProxy(receiver) {
    this.receiver_ = receiver;
  }
  SpeechRecognitionClientBrowserInterfacePtr.prototype.bindSpeechRecognitionBrowserObserver = function() {
    return SpeechRecognitionClientBrowserInterfaceProxy.prototype.bindSpeechRecognitionBrowserObserver
        .apply(this.ptr.getProxy(), arguments);
  };

  SpeechRecognitionClientBrowserInterfaceProxy.prototype.bindSpeechRecognitionBrowserObserver = function(observer) {
    var params_ = new SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params();
    params_.observer = observer;
    var builder = new codec.MessageV0Builder(
        kSpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Name,
        codec.align(SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params.encodedSize));
    builder.encodeStruct(SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params, params_);
    var message = builder.finish();
    this.receiver_.accept(message);
  };

  function SpeechRecognitionClientBrowserInterfaceStub(delegate) {
    this.delegate_ = delegate;
  }
  SpeechRecognitionClientBrowserInterfaceStub.prototype.bindSpeechRecognitionBrowserObserver = function(observer) {
    return this.delegate_ && this.delegate_.bindSpeechRecognitionBrowserObserver && this.delegate_.bindSpeechRecognitionBrowserObserver(observer);
  }

  SpeechRecognitionClientBrowserInterfaceStub.prototype.accept = function(message) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    case kSpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Name:
      var params = reader.decodeStruct(SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params);
      this.bindSpeechRecognitionBrowserObserver(params.observer);
      return true;
    default:
      return false;
    }
  };

  SpeechRecognitionClientBrowserInterfaceStub.prototype.acceptWithResponder =
      function(message, responder) {
    var reader = new codec.MessageReader(message);
    switch (reader.messageName) {
    default:
      return false;
    }
  };

  function validateSpeechRecognitionClientBrowserInterfaceRequest(messageValidator) {
    var message = messageValidator.message;
    var paramsClass = null;
    switch (message.getName()) {
      case kSpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Name:
        if (!message.expectsResponse() && !message.isResponse())
          paramsClass = SpeechRecognitionClientBrowserInterface_BindSpeechRecognitionBrowserObserver_Params;
      break;
    }
    if (paramsClass === null)
      return validator.validationError.NONE;
    return paramsClass.validate(messageValidator, messageValidator.message.getHeaderNumBytes());
  }

  function validateSpeechRecognitionClientBrowserInterfaceResponse(messageValidator) {
    return validator.validationError.NONE;
  }

  var SpeechRecognitionClientBrowserInterface = {
    name: 'media.mojom.SpeechRecognitionClientBrowserInterface',
    kVersion: 0,
    ptrClass: SpeechRecognitionClientBrowserInterfacePtr,
    proxyClass: SpeechRecognitionClientBrowserInterfaceProxy,
    stubClass: SpeechRecognitionClientBrowserInterfaceStub,
    validateRequest: validateSpeechRecognitionClientBrowserInterfaceRequest,
    validateResponse: null,
  };
  SpeechRecognitionClientBrowserInterfaceStub.prototype.validator = validateSpeechRecognitionClientBrowserInterfaceRequest;
  SpeechRecognitionClientBrowserInterfaceProxy.prototype.validator = null;
  exports.ConfidenceLevel = ConfidenceLevel;
  exports.SpeechRecognitionMode = SpeechRecognitionMode;
  exports.HypothesisParts = HypothesisParts;
  exports.TimingInformation = TimingInformation;
  exports.SpeechRecognitionResult = SpeechRecognitionResult;
  exports.LanguageIdentificationEvent = LanguageIdentificationEvent;
  exports.SpeechRecognitionOptions = SpeechRecognitionOptions;
  exports.SpeechRecognitionContext = SpeechRecognitionContext;
  exports.SpeechRecognitionContextPtr = SpeechRecognitionContextPtr;
  exports.SpeechRecognitionContextAssociatedPtr = SpeechRecognitionContextAssociatedPtr;
  exports.SpeechRecognitionService = SpeechRecognitionService;
  exports.SpeechRecognitionServicePtr = SpeechRecognitionServicePtr;
  exports.SpeechRecognitionServiceAssociatedPtr = SpeechRecognitionServiceAssociatedPtr;
  exports.AudioSourceFetcher = AudioSourceFetcher;
  exports.AudioSourceFetcherPtr = AudioSourceFetcherPtr;
  exports.AudioSourceFetcherAssociatedPtr = AudioSourceFetcherAssociatedPtr;
  exports.SpeechRecognitionServiceClient = SpeechRecognitionServiceClient;
  exports.SpeechRecognitionServiceClientPtr = SpeechRecognitionServiceClientPtr;
  exports.SpeechRecognitionServiceClientAssociatedPtr = SpeechRecognitionServiceClientAssociatedPtr;
  exports.SpeechRecognitionRecognizer = SpeechRecognitionRecognizer;
  exports.SpeechRecognitionRecognizerPtr = SpeechRecognitionRecognizerPtr;
  exports.SpeechRecognitionRecognizerAssociatedPtr = SpeechRecognitionRecognizerAssociatedPtr;
  exports.SpeechRecognitionRecognizerClient = SpeechRecognitionRecognizerClient;
  exports.SpeechRecognitionRecognizerClientPtr = SpeechRecognitionRecognizerClientPtr;
  exports.SpeechRecognitionRecognizerClientAssociatedPtr = SpeechRecognitionRecognizerClientAssociatedPtr;
  exports.SpeechRecognitionBrowserObserver = SpeechRecognitionBrowserObserver;
  exports.SpeechRecognitionBrowserObserverPtr = SpeechRecognitionBrowserObserverPtr;
  exports.SpeechRecognitionBrowserObserverAssociatedPtr = SpeechRecognitionBrowserObserverAssociatedPtr;
  exports.SpeechRecognitionClientBrowserInterface = SpeechRecognitionClientBrowserInterface;
  exports.SpeechRecognitionClientBrowserInterfacePtr = SpeechRecognitionClientBrowserInterfacePtr;
  exports.SpeechRecognitionClientBrowserInterfaceAssociatedPtr = SpeechRecognitionClientBrowserInterfaceAssociatedPtr;
})();